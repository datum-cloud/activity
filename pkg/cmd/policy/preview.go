package policy

import (
	"context"
	"encoding/json"
	"fmt"
	"os"

	"github.com/spf13/cobra"
	auditv1 "k8s.io/apiserver/pkg/apis/audit/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/yaml"
	"k8s.io/cli-runtime/pkg/genericclioptions"
	"k8s.io/cli-runtime/pkg/printers"
	"k8s.io/kubectl/pkg/cmd/util"

	activityv1alpha1 "go.miloapis.com/activity/pkg/apis/activity/v1alpha1"
	clientset "go.miloapis.com/activity/pkg/client/clientset/versioned"
	"go.miloapis.com/activity/pkg/cmd/common"
)

// PreviewOptions contains the options for previewing a policy
type PreviewOptions struct {
	// File paths
	PolicyFile string
	InputFile  string

	// Inline input
	InputAudit string

	// Flags
	DryRun bool

	// Common flags
	Output common.OutputFlags

	PrintFlags *genericclioptions.PrintFlags
	genericclioptions.IOStreams
	Factory util.Factory
}

// NewPreviewOptions creates a new PreviewOptions with default values
func NewPreviewOptions(f util.Factory, ioStreams genericclioptions.IOStreams) *PreviewOptions {
	return &PreviewOptions{
		IOStreams:  ioStreams,
		Factory:    f,
		PrintFlags: genericclioptions.NewPrintFlags(""),
	}
}

// NewPreviewCommand creates the policy preview command
func NewPreviewCommand(f util.Factory, ioStreams genericclioptions.IOStreams) *cobra.Command {
	o := NewPreviewOptions(f, ioStreams)

	cmd := &cobra.Command{
		Use:   "preview -f <policy-file> [flags]",
		Short: "Test an ActivityPolicy against sample inputs",
		Long: `Test an ActivityPolicy against sample inputs without deploying it.

This command allows you to verify that your policy rules match correctly and
generate the expected summaries before deploying the policy to your cluster.

The preview accepts multiple inputs (audit logs and/or events) and returns the
rendered Activity objects that would be generated by the policy.

Input File Format (YAML):
  inputs:
    - type: audit
      audit:
        verb: create
        user:
          username: alice@example.com
        objectRef:
          apiGroup: networking.datumapis.com
          resource: httpproxies
          name: my-proxy
        responseStatus:
          code: 201

Examples:
  # Preview policy with sample inputs
  kubectl activity policy preview -f policy.yaml --input samples.yaml

  # Quick test with inline audit event
  kubectl activity policy preview -f policy.yaml \
    --input-audit '{"verb":"create","user":{"username":"alice"}}'

  # Validate policy syntax only
  kubectl activity policy preview -f policy.yaml --dry-run

  # JSON output for scripting
  kubectl activity policy preview -f policy.yaml --input samples.yaml -o json
`,
		SilenceUsage: true,
		RunE: func(cmd *cobra.Command, args []string) error {
			if err := o.Complete(cmd); err != nil {
				return err
			}
			if err := o.Validate(); err != nil {
				return err
			}
			return o.Run(cmd.Context())
		},
	}

	// Add flags
	cmd.Flags().StringVarP(&o.PolicyFile, "file", "f", "", "Path to ActivityPolicy YAML file (required)")
	cmd.Flags().StringVar(&o.InputFile, "input", "", "Path to sample inputs file (YAML)")
	cmd.Flags().StringVar(&o.InputAudit, "input-audit", "", "Inline audit event JSON")
	cmd.Flags().BoolVar(&o.DryRun, "dry-run", false, "Validate policy syntax only")

	common.AddOutputFlags(cmd, &o.Output)
	o.PrintFlags.AddFlags(cmd)

	cmd.MarkFlagRequired("file")

	return cmd
}

// Complete fills in missing options
func (o *PreviewOptions) Complete(cmd *cobra.Command) error {
	if o.Out == nil {
		o.Out = os.Stdout
	}
	if o.ErrOut == nil {
		o.ErrOut = os.Stderr
	}
	if o.In == nil {
		o.In = os.Stdin
	}
	return nil
}

// Validate checks that required options are set correctly
func (o *PreviewOptions) Validate() error {
	if o.PolicyFile == "" {
		return fmt.Errorf("--file is required")
	}

	if !o.DryRun && o.InputFile == "" && o.InputAudit == "" {
		return fmt.Errorf("either --input or --input-audit is required (use --dry-run to validate syntax only)")
	}

	return nil
}

// Run executes the policy preview
func (o *PreviewOptions) Run(ctx context.Context) error {
	config, err := o.Factory.ToRESTConfig()
	if err != nil {
		return fmt.Errorf("failed to get kubeconfig: %w", err)
	}

	client, err := clientset.NewForConfig(config)
	if err != nil {
		return fmt.Errorf("failed to create activity client: %w", err)
	}

	// Read policy file
	policySpec, err := o.readPolicyFile()
	if err != nil {
		return err
	}

	// Dry run mode - just validate the policy
	if o.DryRun {
		fmt.Fprintf(o.Out, "Policy syntax is valid.\n")
		return nil
	}

	// Read inputs
	inputs, err := o.readInputs()
	if err != nil {
		return err
	}

	// Create preview request
	preview := &activityv1alpha1.PolicyPreview{
		ObjectMeta: metav1.ObjectMeta{
			GenerateName: "preview-",
		},
		Spec: activityv1alpha1.PolicyPreviewSpec{
			Policy: policySpec,
			Inputs: inputs,
		},
	}

	if o.Output.Debug {
		fmt.Fprintf(o.ErrOut, "DEBUG: Preview request: %+v\n", preview.Spec)
	}

	result, err := client.ActivityV1alpha1().PolicyPreviews().Create(ctx, preview, metav1.CreateOptions{})
	if err != nil {
		return fmt.Errorf("preview failed: %w", err)
	}

	return o.printResults(result)
}

// readPolicyFile reads and parses the policy file
func (o *PreviewOptions) readPolicyFile() (activityv1alpha1.ActivityPolicySpec, error) {
	var spec activityv1alpha1.ActivityPolicySpec

	file, err := os.Open(o.PolicyFile)
	if err != nil {
		return spec, fmt.Errorf("failed to open policy file: %w", err)
	}
	defer file.Close()

	// Read the full ActivityPolicy object
	var policy activityv1alpha1.ActivityPolicy
	decoder := yaml.NewYAMLOrJSONDecoder(file, 4096)
	if err := decoder.Decode(&policy); err != nil {
		return spec, fmt.Errorf("failed to parse policy file: %w", err)
	}

	return policy.Spec, nil
}

// readInputs reads sample inputs from file or inline flag
func (o *PreviewOptions) readInputs() ([]activityv1alpha1.PolicyPreviewInput, error) {
	if o.InputFile != "" {
		return o.readInputFile()
	}

	if o.InputAudit != "" {
		return o.readInlineAudit()
	}

	return nil, fmt.Errorf("no inputs provided")
}

// readInputFile reads inputs from a YAML file
func (o *PreviewOptions) readInputFile() ([]activityv1alpha1.PolicyPreviewInput, error) {
	file, err := os.Open(o.InputFile)
	if err != nil {
		return nil, fmt.Errorf("failed to open input file: %w", err)
	}
	defer file.Close()

	var inputDoc struct {
		Inputs []activityv1alpha1.PolicyPreviewInput `json:"inputs"`
	}

	decoder := yaml.NewYAMLOrJSONDecoder(file, 4096)
	if err := decoder.Decode(&inputDoc); err != nil {
		return nil, fmt.Errorf("failed to parse input file: %w", err)
	}

	return inputDoc.Inputs, nil
}

// readInlineAudit creates an input from inline JSON
func (o *PreviewOptions) readInlineAudit() ([]activityv1alpha1.PolicyPreviewInput, error) {
	var auditEvent auditv1.Event

	if err := json.Unmarshal([]byte(o.InputAudit), &auditEvent); err != nil {
		return nil, fmt.Errorf("failed to parse audit event JSON: %w\nProvide a valid JSON audit event, e.g., {\"verb\":\"create\",\"user\":{\"username\":\"alice\"}}", err)
	}

	input := activityv1alpha1.PolicyPreviewInput{
		Type:  "audit",
		Audit: &auditEvent,
	}

	return []activityv1alpha1.PolicyPreviewInput{input}, nil
}

// printResults outputs the preview results
func (o *PreviewOptions) printResults(result *activityv1alpha1.PolicyPreview) error {
	// Check for errors
	if result.Status.Error != "" {
		fmt.Fprintf(o.ErrOut, "Error: %s\n", result.Status.Error)
		return fmt.Errorf("preview failed")
	}

	if common.IsDefaultOutputFormat(o.PrintFlags) {
		return o.printTable(result)
	}

	printer, err := common.CreatePrinter(o.PrintFlags)
	if err != nil {
		return fmt.Errorf("failed to create printer: %w", err)
	}

	return printer.PrintObj(result, o.Out)
}

// printTable prints preview results as a formatted table
func (o *PreviewOptions) printTable(result *activityv1alpha1.PolicyPreview) error {
	table := &metav1.Table{
		TypeMeta: metav1.TypeMeta{
			Kind:       "Table",
			APIVersion: "meta.k8s.io/v1",
		},
		ColumnDefinitions: []metav1.TableColumnDefinition{
			{Name: "Input", Type: "string", Description: "Input description"},
			{Name: "Matched", Type: "string", Description: "Whether a rule matched"},
			{Name: "Rule", Type: "string", Description: "Matched rule index"},
			{Name: "Activity Summary", Type: "string", Description: "Generated activity summary or error"},
		},
		Rows: make([]metav1.TableRow, 0, len(result.Status.Results)),
	}

	for i, res := range result.Status.Results {
		inputDesc := fmt.Sprintf("Input #%d", res.InputIndex+1)
		matched := "yes"
		if !res.Matched {
			matched = "no"
		}

		ruleIdx := "-"
		if res.MatchedRuleIndex >= 0 {
			ruleIdx = fmt.Sprintf("%d (%s)", res.MatchedRuleIndex, res.MatchedRuleType)
		}

		summaryOrError := "-"
		if res.Error != "" {
			summaryOrError = fmt.Sprintf("ERROR: %s", res.Error)
		} else if res.Matched && i < len(result.Status.Activities) {
			// Find the corresponding activity
			for _, activity := range result.Status.Activities {
				summaryOrError = activity.Spec.Summary
				break
			}
		}

		row := metav1.TableRow{
			Cells: []interface{}{inputDesc, matched, ruleIdx, summaryOrError},
		}
		table.Rows = append(table.Rows, row)
	}

	tablePrinter := printers.NewTablePrinter(printers.PrintOptions{
		WithNamespace: false,
		Wide:          true,
		NoHeaders:     o.Output.NoHeaders,
	})

	return tablePrinter.PrintObj(table, o.Out)
}

// NewPolicyCommand creates the policy parent command
func NewPolicyCommand(f util.Factory, ioStreams genericclioptions.IOStreams) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "policy",
		Short: "Policy management commands",
		Long:  `Commands for working with ActivityPolicy resources.`,
	}

	cmd.AddCommand(NewPreviewCommand(f, ioStreams))

	return cmd
}
