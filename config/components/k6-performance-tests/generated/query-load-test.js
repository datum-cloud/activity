// Code generated by task load:generate. DO NOT EDIT.
// Source: test/load/src/

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend, Counter } from 'k6/metrics';

// Custom metrics
const querySuccessRate = new Rate('query_success_rate');
const queryDuration = new Trend('query_duration');
const queriesExecuted = new Counter('queries_executed');
const celFilterErrors = new Counter('cel_filter_errors');

// Configuration
export const options = {
  // Disable TLS verification by default for self-signed certs
  // Override by setting K6_INSECURE_SKIP_TLS_VERIFY=false
  insecureSkipTLSVerify: __ENV.K6_INSECURE_SKIP_TLS_VERIFY !== 'false',

  // Scenarios for different query patterns
  scenarios: {
    // Scenario 1: Steady load - simulating normal query traffic
    steady_load: {
      executor: 'constant-vus',
      vus: 10,
      duration: '5m',
      tags: { scenario: 'steady' },
    },
    // Scenario 2: Ramp up - simulating increasing load
    ramp_up: {
      executor: 'ramping-vus',
      startVUs: 0,
      stages: [
        { duration: '2m', target: 20 },
        { duration: '5m', target: 50 },
        { duration: '2m', target: 100 },
        { duration: '5m', target: 100 },
        { duration: '2m', target: 0 },
      ],
      tags: { scenario: 'ramp' },
      startTime: '5m', // Start after steady_load
    },
    // Scenario 3: Spike test - simulating sudden traffic spikes
    spike: {
      executor: 'ramping-vus',
      startVUs: 0,
      stages: [
        { duration: '10s', target: 200 },
        { duration: '1m', target: 200 },
        { duration: '10s', target: 0 },
      ],
      tags: { scenario: 'spike' },
      startTime: '16m', // Start after ramp_up
    },
  },

  thresholds: {
    // HTTP request duration should be below 2000ms for 95% of requests
    http_req_duration: ['p(95)<2000'],
    // Query success rate should be above 95%
    query_success_rate: ['rate>0.95'],
    // HTTP request failures should be below 5%
    http_req_failed: ['rate<0.05'],
  },
};

// Environment configuration
const BASE_URL = __ENV.API_SERVER_URL || 'https://activity-apiserver.activity-system.svc.cluster.local:443';
const API_PATH = '/apis/activity.miloapis.com/v1alpha1/auditlogqueries';
const TOKEN = __ENV.KUBE_TOKEN || '';

// mTLS certificate paths
const TLS_CERT_FILE = __ENV.TLS_CERT_FILE || '';
const TLS_KEY_FILE = __ENV.TLS_KEY_FILE || '';

// Configure TLS options globally if certificates are provided
if (TLS_CERT_FILE && TLS_KEY_FILE) {
  try {
    const certContent = open(TLS_CERT_FILE);
    const keyContent = open(TLS_KEY_FILE);

    // Validate that certificates were actually loaded
    if (!certContent || certContent.length === 0) {
      throw new Error('Certificate file is empty');
    }
    if (!keyContent || keyContent.length === 0) {
      throw new Error('Key file is empty');
    }

    console.log(`Loaded client certificate from ${TLS_CERT_FILE} (${certContent.length} bytes)`);
    console.log(`Loaded client key from ${TLS_KEY_FILE} (${keyContent.length} bytes)`);

    options.tlsAuth = [
      {
        cert: certContent,
        key: keyContent,
      },
    ];
  } catch (error) {
    console.error(`FATAL: Failed to load TLS certificates: ${error}`);
    console.error(`Certificate paths:`);
    console.error(`   TLS_CERT_FILE: ${TLS_CERT_FILE}`);
    console.error(`   TLS_KEY_FILE: ${TLS_KEY_FILE}`);
    console.error(`TLS certificates were specified but could not be loaded.`);
    console.error(`Either fix the certificate configuration or remove TLS_CERT_FILE/TLS_KEY_FILE env vars.`);
    throw error; // This will cause k6 to fail immediately during init
  }
} else if (TLS_CERT_FILE || TLS_KEY_FILE) {
  // One is set but not the other - this is a configuration error
  const errorMsg = `FATAL: Both TLS_CERT_FILE and TLS_KEY_FILE must be set together`;
  console.error(errorMsg);
  console.error(`   TLS_CERT_FILE: ${TLS_CERT_FILE || '(not set)'}`);
  console.error(`   TLS_KEY_FILE: ${TLS_KEY_FILE || '(not set)'}`);
  throw new Error(errorMsg);
} else {
  // No TLS certificates configured - this is fine, will use token auth
  console.log('TLS client certificates not configured, using token-based authentication');
}

// Query templates with different complexity levels
const queryTemplates = [
  // Simple queries
  {
    name: 'simple_verb_filter',
    filter: "verb == 'create'",
    limit: 100,
  },
  {
    name: 'simple_namespace_filter',
    filter: "objectRef.namespace == 'default'",
    limit: 100,
  },
  {
    name: 'simple_resource_filter',
    filter: "objectRef.resource == 'pods'",
    limit: 100,
  },
  // Medium complexity queries
  {
    name: 'medium_combined_filter',
    filter: "verb == 'delete' && objectRef.namespace == 'default'",
    limit: 100,
  },
  {
    name: 'medium_multi_verb',
    filter: "verb in ['create', 'update', 'delete']",
    limit: 100,
  },
  {
    name: 'medium_user_filter',
    filter: "user.username.startsWith('system:') && verb == 'get'",
    limit: 100,
  },
  // Complex queries
  {
    name: 'complex_multi_condition',
    filter: "objectRef.namespace in ['default', 'kube-system'] && objectRef.resource == 'deployments' && verb in ['create', 'update']",
    limit: 100,
  },
  {
    name: 'complex_timestamp_range',
    filter: `stageTimestamp >= timestamp('2024-01-01T00:00:00Z') && verb == 'delete'`,
    limit: 50,
  },
  {
    name: 'complex_secrets_audit',
    filter: "objectRef.resource == 'secrets' && stage == 'ResponseComplete' && verb in ['get', 'list']",
    limit: 100,
  },
  // Pagination queries (smaller limits for testing pagination)
  {
    name: 'pagination_small',
    filter: "verb == 'get'",
    limit: 10,
  },
  {
    name: 'pagination_medium',
    filter: "objectRef.namespace == 'default'",
    limit: 25,
  },
];

// Get HTTP request options
function getRequestOptions() {
  const options = {
    headers: {
      'Content-Type': 'application/json',
    },
    timeout: '30s',
  };

  // Fallback to bearer token if provided (for backwards compatibility)
  // Note: mTLS certificates are configured globally in options.tlsAuth
  if (TOKEN && !TLS_CERT_FILE) {
    options.headers['Authorization'] = `Bearer ${TOKEN}`;
  }

  return options;
}

// Create AuditLogQuery request body
function createQueryRequest(template, continueAfter) {
  // Default time range: last 24 hours
  const now = new Date();
  const yesterday = new Date(now.getTime() - 24 * 60 * 60 * 1000);

  const spec = {
    startTime: yesterday.toISOString(),
    endTime: now.toISOString(),
    filter: template.filter,
    limit: template.limit,
  };

  // Only add continueAfter if it's a valid non-empty string
  if (continueAfter && typeof continueAfter === 'string' && continueAfter.trim().length > 0) {
    spec.continueAfter = continueAfter;
  }

  const query = {
    apiVersion: 'activity.miloapis.com/v1alpha1',
    kind: 'AuditLogQuery',
    metadata: {
      name: `load-test-${template.name}-${Date.now()}`,
    },
    spec,
  };

  return JSON.stringify(query);
}

// Execute a single query
function executeQuery(template) {
  const payload = createQueryRequest(template);
  const response = http.post(`${BASE_URL}${API_PATH}`, payload, getRequestOptions());

  queriesExecuted.add(1);

  // Check response
  const success = check(response, {
    'status is 201': (r) => r.status === 201,
    'response has body': (r) => r.body !== null && r.body !== undefined,
    'query has results': (r) => {
      try {
        const body = JSON.parse(r.body);
        return body.status !== undefined;
      } catch {
        return false;
      }
    },
  });

  querySuccessRate.add(success ? 1 : 0);
  queryDuration.add(response.timings.duration);

  // Track CEL filter errors
  if (response.status === 400 && response.body) {
    try {
      const body = JSON.parse(response.body);
      if (body.message?.includes('filter') || body.message?.includes('CEL')) {
        celFilterErrors.add(1);
      }
    } catch {
      // Ignore parsing errors
    }
  }

  // Log errors for debugging
  if (!success) {
    console.error(`Query failed: ${template.name}, Status: ${response.status}, Body: ${response.body}`);
  }
}

// Execute query with pagination
function executeQueryWithPagination(template, maxPages = 3) {
  let continueAfter;
  let pageCount = 0;

  do {
    const payload = createQueryRequest(template, continueAfter);
    const response = http.post(`${BASE_URL}${API_PATH}`, payload, getRequestOptions());

    queriesExecuted.add(1);
    pageCount++;

    const success = check(response, {
      'pagination status is 201': (r) => r.status === 201,
      'pagination query has results': (r) => {
        try {
          const body = JSON.parse(r.body);
          return body.status !== undefined;
        } catch {
          return false;
        }
      },
    });

    querySuccessRate.add(success ? 1 : 0);
    queryDuration.add(response.timings.duration);

    if (!success) {
      console.error(`Pagination query failed: ${template.name}, Page: ${pageCount}, Status: ${response.status}, Body: ${response.body}`);
      break;
    }

    // Get next page cursor
    try {
      const body = JSON.parse(response.body);
      const nextCursor = body.status?.continueAfter;

      // Only set continueAfter if we have a valid non-empty string
      if (nextCursor && typeof nextCursor === 'string' && nextCursor.trim().length > 0) {
        continueAfter = nextCursor;
      } else {
        // No more pages
        continueAfter = undefined;
      }
    } catch (e) {
      console.error(`Failed to parse pagination response: ${e}`);
      break;
    }

    // Small delay between pagination requests
    sleep(0.1);
  } while (continueAfter && pageCount < maxPages);
}

// Main test function
export default function() {
  // Randomly select a query template (weighted towards simpler queries)
  const rand = Math.random();
  let templateIndex;

  if (rand < 0.5) {
    // 50% simple queries
    templateIndex = Math.floor(Math.random() * 3);
  } else if (rand < 0.8) {
    // 30% medium queries
    templateIndex = 3 + Math.floor(Math.random() * 3);
  } else if (rand < 0.95) {
    // 15% complex queries
    templateIndex = 6 + Math.floor(Math.random() * 3);
  } else {
    // 5% pagination queries
    templateIndex = 9 + Math.floor(Math.random() * 2);
  }

  const template = queryTemplates[templateIndex];

  // Execute pagination queries separately
  if (template.name.startsWith('pagination_')) {
    executeQueryWithPagination(template);
  } else {
    executeQuery(template);
  }

  // Think time between requests (0.5-2 seconds)
  sleep(Math.random() * 1.5 + 0.5);
}

// Setup function - runs once per VU
export function setup() {
  console.log(`Starting load test against ${BASE_URL}${API_PATH}`);
  console.log(`Total query templates: ${queryTemplates.length}`);
}

// Teardown function - runs once after all VUs finish
export function teardown() {
  console.log('Load test completed');
}
