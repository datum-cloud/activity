---
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: vector-sidecar
  namespace: activity-system
spec:
  interval: 5m
  timeout: 1m

  chart:
    spec:
      chart: vector
      version: 0.49.x
      sourceRef:
        kind: HelmRepository
        name: vector-sidecar
        namespace: activity-system
      interval: 1h

  values:
    role: Agent
    daemonset:
      enabled: true

    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 500m
        memory: 512Mi

    podMonitor:
      enabled: true
      port: internal-promet

    service:
      enabled: true
      type: ClusterIP
      ports:
        - name: metrics
          port: 9090
          protocol: TCP
        - name: webhook
          port: 8080
          protocol: TCP
        - name: k8s-events
          port: 8081
          protocol: TCP

    customConfig:
      data_dir: /vector-data-dir

      api:
        enabled: true
        address: 0.0.0.0:8686

      sources:
        # Webhook endpoint for receiving audit logs via HTTP
        webhook:
          type: http_server
          address: 0.0.0.0:8080
          path: /events
          strict_path: true
          decoding:
            codec: json
          framing:
            method: bytes

        # Webhook endpoint for receiving Kubernetes Events from kubernetes-event-exporter
        k8s_events_webhook:
          type: http_server
          address: 0.0.0.0:8081
          path: /k8s-events
          strict_path: true
          decoding:
            codec: json
          framing:
            method: bytes

        internal_metrics:
          type: internal_metrics
          namespace: vector

      transforms:
        # Extract individual events from webhook EventList batch
        # The Kubernetes API server webhook sends batches in this format:
        # {
        #   "kind": "EventList",
        #   "apiVersion": "audit.k8s.io/v1",
        #   "items": [
        #     { "kind": "Event", ... },
        #     { "kind": "Event", ... }
        #   ]
        # }
        # This transform splits the items array into individual events
        parse_webhook_batch:
          type: remap
          inputs:
            - webhook
          source: |
            # Check if this is an EventList batch from Kubernetes webhook
            if exists(.kind) && .kind == "EventList" && exists(.items) {
              # Extract the items array and emit each item as a separate event
              . = .items
            }

        # Set event timestamp from audit log stageTimestamp
        #
        # This is critical for accurate lag metrics - Vector will use this timestamp
        # to calculate source_lag_time_seconds
        set_event_timestamp:
          type: remap
          inputs:
            - parse_webhook_batch
          source: |
            # Parse stageTimestamp from the audit event and set as Vector's timestamp
            # This allows Vector to calculate accurate lag metrics
            if exists(.stageTimestamp) {
              .timestamp = parse_timestamp!(.stageTimestamp, format: "%+")
            }

        # ========================================================================
        # Kubernetes Events Pipeline (from kubernetes-event-exporter)
        # ========================================================================

        # Set timestamp for K8s events from lastTimestamp or firstTimestamp
        set_k8s_event_timestamp:
          type: remap
          inputs:
            - k8s_events_webhook
          source: |
            # Use lastTimestamp for the event timestamp (most recent occurrence)
            # Fall back to firstTimestamp, then eventTime, then now()
            if exists(.lastTimestamp) && .lastTimestamp != "" && .lastTimestamp != null {
              ts, err = parse_timestamp(.lastTimestamp, format: "%+")
              if err == null {
                .timestamp = ts
              }
            } else if exists(.firstTimestamp) && .firstTimestamp != "" && .firstTimestamp != null {
              ts, err = parse_timestamp(.firstTimestamp, format: "%+")
              if err == null {
                .timestamp = ts
              }
            } else if exists(.eventTime) && .eventTime != "" && .eventTime != null {
              ts, err = parse_timestamp(.eventTime, format: "%+")
              if err == null {
                .timestamp = ts
              }
            }

            if !exists(.timestamp) {
              .timestamp = now()
            }

      sinks:
        # Publish to NATS JetStream
        nats_jetstream:
          type: nats
          inputs:
            - set_event_timestamp
          url: nats://nats.nats-system.svc.cluster.local:4222
          connection_name: vector-sidecar
          subject: audit.k8s.activity
          encoding:
            codec: json
          healthcheck:
            enabled: true

          jetstream:
            enabled: true
            headers:
              # NATS message ID for de-duplication
              # Uses the Kubernetes auditID as the NATS message ID to enable
              # JetStream's duplicate detection within the duplicateWindow (10m)
              # This prevents duplicate events from webhook retries or Vector restarts
              message_id: '{{ "{{" }} .auditID {{ "}}" }}'

          # Buffer for durability
          # 10GB disk buffer to survive NATS outages
          buffer:
            type: disk
            max_size: 10737418240
            when_full: block

        # Publish Kubernetes Events to NATS JetStream EVENTS stream
        nats_k8s_events:
          type: nats
          inputs:
            - set_k8s_event_timestamp
          url: nats://nats.nats-system.svc.cluster.local:4222
          connection_name: vector-sidecar-k8s-events
          # Subject includes namespace for routing: events.{namespace}
          subject: 'events.{{ "{{" }} .metadata.namespace {{ "}}" }}'
          encoding:
            codec: json
          healthcheck:
            enabled: true

          jetstream:
            enabled: true
            headers:
              # NATS message ID for de-duplication using event UID
              message_id: '{{ "{{" }} .metadata.uid {{ "}}" }}'

          # Buffer for durability
          buffer:
            type: disk
            max_size: 1073741824  # 1GB buffer for events
            when_full: block

        internal_prometheus:
          type: prometheus_exporter
          inputs:
            - internal_metrics
          address: 0.0.0.0:9091
          default_namespace: vector_internal

    env:
      - name: CLUSTER_NAME
        value: "default"
      - name: VECTOR_LOG
        value: "info"
      - name: VECTOR_LOG_FORMAT
        value: "json"

    persistence:
      enabled: true
      storageClassName: ""
      accessModes:
        - ReadWriteOnce
      size: 15Gi

    extraVolumes: []
    extraVolumeMounts: []

  install:
    crds: Create
    createNamespace: false

  upgrade:
    crds: CreateReplace

  uninstall:
    keepHistory: false
